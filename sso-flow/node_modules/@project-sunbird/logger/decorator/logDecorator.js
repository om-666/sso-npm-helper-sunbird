"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var logger_1 = require("./../logger/logger");
var NS_PER_SEC = 1e9;
var defaultClassLoggerOptions = {
    logLevel: 'debug',
    logTime: false,
};
function ClassLogger(classLoggerOptions) {
    if (classLoggerOptions === void 0) { classLoggerOptions = defaultClassLoggerOptions; }
    return function (constructor) {
        Object.getOwnPropertyNames(constructor.prototype)
            .filter(function (methodName) {
            return (!classLoggerOptions.logMethods || _.includes(classLoggerOptions.logMethods, methodName)) &&
                methodName !== 'constructor' &&
                typeof constructor.prototype[methodName] === 'function';
        })
            .forEach(function (methodName) {
            var originalMethod = constructor.prototype[methodName];
            if (originalMethod.__loggerAttached) {
                return;
            }
            logger_1.logger.debug('classDecorator warping method', constructor.name + '.' + methodName);
            constructor.prototype[methodName] = wrapMethodWithLogAsync(originalMethod, methodName, constructor.name, {
                logLevel: classLoggerOptions.logLevel,
                logTime: classLoggerOptions.logTime,
            });
        });
    };
}
exports.ClassLogger = ClassLogger;
function wrapMethodWithLogAsync(method, methodName, className, options) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // async added creates promise for sync function also, this need to be handled
        var startHrTime = process.hrtime();
        var loggerMethod = logger_1.logger[options.logLevel] || logger_1.logger.debug;
        var argMap = args.map(function (arg) {
            if (typeof arg === 'function') {
                return 'function';
            }
            if (_.get(arg, '__proto__.constructor.name') === 'IncomingMessage') {
                return 'RequestObject';
            }
            if (_.get(arg, '__proto__.constructor.name') === 'ServerResponse') {
                return 'ResponseObject';
            }
            return arg;
        });
        loggerMethod.apply(void 0, __spreadArrays([className + "." + methodName + " called with: "], argMap));
        try {
            var result = method.apply(this, args);
            if (_.get(result, '__proto__.constructor.name') !== 'Promise' &&
                _.get(result, '__proto__.constructor.name') !== 'WrappedPromise') {
                var diff = process.hrtime(startHrTime);
                var endTime = (diff[0] * NS_PER_SEC + diff[1]) / NS_PER_SEC;
                loggerMethod("===> " + className + "." + methodName + " returned with: ", result, ". Took " + endTime + " sec");
                return result;
            }
            return result
                .then(function (response) {
                var diff = process.hrtime(startHrTime);
                var endTime = (diff[0] * NS_PER_SEC + diff[1]) / NS_PER_SEC;
                loggerMethod("===> " + className + "." + methodName + " returned with: ", response, ". Took " + endTime + " sec");
                return response;
            })
                .catch(function (error) {
                var diff = process.hrtime(startHrTime);
                var endTime = (diff[0] * NS_PER_SEC + diff[1]) / NS_PER_SEC;
                loggerMethod("===> " + className + "." + methodName + " failed with: ", error, ". Took " + endTime + " sec");
                throw error;
            });
        }
        catch (error) {
            var diff = process.hrtime(startHrTime);
            var endTime = (diff[0] * NS_PER_SEC + diff[1]) / NS_PER_SEC;
            loggerMethod("===> " + className + "." + methodName + " failed with: ", error, ". Took " + endTime + " sec");
            throw error;
        }
    };
}
function MethodLogger(methodLogOption) {
    if (methodLogOption === void 0) { methodLogOption = defaultClassLoggerOptions; }
    return function (classRef, methodName, methodRef) {
        if (methodRef === undefined) {
            methodRef = Object.getOwnPropertyDescriptor(classRef, methodName);
        }
        methodRef.value = wrapMethodWithLogAsync(methodRef.value, methodName, classRef.constructor.name, methodLogOption);
        methodRef.value.__loggerAttached = true;
    };
}
exports.MethodLogger = MethodLogger;
function ProxyLogger(targetObject, targetObjectName, methodLogOption) {
    if (methodLogOption === void 0) { methodLogOption = defaultClassLoggerOptions; }
    return new Proxy(targetObject, {
        get: function (target, prop, receiver) {
            var property = Reflect.get(target, prop, receiver);
            if (typeof property === 'function') {
                return wrapMethodWithLogAsync(property, prop, targetObjectName, methodLogOption);
            }
            return property;
        },
    });
}
exports.ProxyLogger = ProxyLogger;
__export(require("../logger/interface"));
